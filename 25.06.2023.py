# range(a) - функция, создает диапазон [0, a)
# range() возвращает "утрируемые объекты диапазона", поэтому необходимо использовать функцию list(), которая преобразует свой аргумент в список
numbers = list(range(11))
print(numbers) # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# range(a, b) - функция, создает диапазон [a, b)
numbers2 = list(range(2, 10))
print(numbers2) # => [2, 3, 4, 5, 6, 7, 8, 9]

# range(a, b, c) - функция, создает диапазон [a, b) с шагом c
numbers3 = list(range(5, 21, 5))
print(numbers3) # => [5, 10, 15, 20]


num = [1, 2, 3, 4, 5]
i = 0
length = len(num) - 1
while i <= length:
    print(num[i])
    i += 1
print('-' * 15)

for element in num:
    print(element)
print('-' * 15)

# функция range() создает итерируемый объект диапазона и цикл for может проходиться по его объектам
j = 1
for test in range(10):
    print(str(j) + '. Hello!')
    j += 1
print('-' * 15)

# Определение собственной функции и вызов:
def print_spam():
    print('spam\n' * 3)
print_spam()

# Собственная функция, принимающая один аргумент:
def multiply(number): # здесь number - параметр ф-ии
    print(number * 2)
multiply(5) # => 10 # здесь 5 - аргумент ф-ии

# Ф-я, возвращающая максимальное чило:
def max(a, b):
    x = 0
    if a > b:
        return a # return останавливает исполнение блока
    else:
        return b
print(max(2, 7)) # => 7
# print(x) 
# переменные, созданные внутри ф-ии, существуют локально только в этой ф-ии, они уничтожаются, когда ф-я перестает исполняться, поэтому print(x) - будет ошибкой, такой переменной нет 

# Строки документирования
def hello():
    '''Ф-я печатает на экран "Hello!"'''
    print('Hello!')
hello()
print(hello.__doc__) # Ф-я печатает на экран "Hello!"
# __doc__ позволяет получить доступ к строке документирования
say_hello = hello # присваеваем новой переменной переменную ф-ю hello(), пишем без (), потому что иначе присвоится результат выполнения ф-ии 
say_hello() # теперь мы так же можем вызвать ф-ю 
# Ф-ии - это переменные, только со своим особенным поведением
print('-' * 15)

def function(a):
    print('Hello, ' + a(2) + '!')
    print('Hello, ' + a(3) + '!')
    print('Hello, ' + function2(4) + '!')

def function2(t):
    return '&&& ' + input('Введите Ваше имя: ') + ' &&&' + str(t)

function(function2)


# Урок №12:
import random # random - название модуля; когда мы пишем: "import модуль", мы получаем в нашем коде объект этого модуля, который совпадает с названием самого модуля и в нем мы можем получать доступ к его методам, ф-ям и др. данным, обращаясь через точку: random.randint()

print(random.randint(1, 100)) # выводит на экран одно рандомное число из диапазона, представленного в виде аргумента
print('-' * 14)

# Выведем на экран десять рандомных чисел:
for k in range(10):
    print(random.randint(1, 100))
print('-' * 14)

# Если мы просто ходим получить отдельную ф-ю из модуля:
from random import randint # тогда в коде мы получаем не объект random, а единственную ф-ю randint():
print(randint(1, 10))

# Если мы хотим импортировать все из молуля:
from random import *

from math import sqrt
print(sqrt(25)) # => 5

from math import *
print(pi)

import math
print(math.pi)

from math import sqrt, pi

# импортируем ф-ю sqrt, но дадим ей название my_sqrt, тогда мы уже не сможем обратиться к ф-ии sqrt:
from math import sqrt as my_sqrt
print(my_sqrt(36))
# необходимо, напр., когда мы импортируем из двух разных модулей ф-ии, которые имеют одинаковые названия

# STL - standart library 
# pip - программа, позволяет устанавливать в свой Python какие-либо пакеты из PyPi
# команда "pip install *название модуля*" устанавливает модуль из PyPi, PyPi - репозиторий, где хранятся различные готовые модули для Python.
